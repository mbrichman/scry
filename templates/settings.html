{% extends "base.html" %}

{% block title %}Settings - ChatGPT Search{% endblock %}

{% block page_title %}Application Settings{% endblock %}

{% block page_styles %}
    .settings-container {
        max-width: 800px;
        margin: 0 auto;
    }
    
    .settings-card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .settings-card h3 {
        margin-top: 0;
        color: #333;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 10px;
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: #333;
    }
    
    .form-group input,
    .form-group textarea {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: inherit;
        font-size: 14px;
    }
    
    .form-group textarea {
        resize: vertical;
        min-height: 60px;
    }
    
    .form-help {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
    }
    
    .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
    
    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
    }
    
    .btn-primary {
        background: #007bff;
        color: white;
    }
    
    .btn-primary:hover {
        background: #0056b3;
    }
    
    .btn-secondary {
        background: #6c757d;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #545b62;
    }
    
    .status-message {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        padding-right: 40px;
        border-radius: 8px;
        display: none;
        z-index: 1000;
        min-width: 300px;
        max-width: 600px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        animation: slideDown 0.3s ease-out;
    }

    .status-message-close {
        position: absolute;
        top: 8px;
        right: 12px;
        background: none;
        border: none;
        font-size: 24px;
        line-height: 1;
        color: inherit;
        opacity: 0.5;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        transition: opacity 0.2s;
    }

    .status-message-close:hover {
        opacity: 1;
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    .status-success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
        display: block;
    }
    
    .status-error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        display: block;
    }
    
    .status-info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
        display: block;
    }

    .status-testing {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
        display: block;
    }
{% endblock %}

{% block content %}
<div class="settings-container">
    <div id="statusMessage" class="status-message">
        <span id="statusMessageText"></span>
        <button id="statusMessageClose" class="status-message-close" onclick="dismissMessage()" aria-label="Close">&times;</button>
    </div>
    
    <div class="settings-card">
        <h3>üåê OpenWebUI Integration</h3>
        
        <form id="settingsForm">
            <div class="form-group">
                <label for="openwebui_url">OpenWebUI URL</label>
                <input 
                    type="url" 
                    id="openwebui_url" 
                    name="openwebui_url" 
                    placeholder="https://openwebui.example.com"
                    value="{{ settings.get('openwebui_url', '') }}"
                >
                <div class="form-help">
                    The base URL of your OpenWebUI instance (e.g., http://localhost:8080)
                </div>
            </div>
            
            <div class="form-group">
                <label for="openwebui_api_key">OpenWebUI API Key</label>
                <input 
                    type="password" 
                    id="openwebui_api_key" 
                    name="openwebui_api_key" 
                    placeholder="Enter your API key"
                    value="{{ settings.get('openwebui_api_key', '') }}"
                >
                <div class="form-help">
                    Your OpenWebUI API key for authentication
                </div>
            </div>
            
            <div class="button-group">
                <button type="submit" class="btn btn-primary">Save Settings</button>
                <button type="button" class="btn btn-secondary" onclick="testConnection()">Test Connection</button>
            </div>
        </form>
    </div>

    <div class="settings-card">
        <h3>üîÑ Sync with OpenWebUI</h3>

        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>Last Sync:</strong>
                    <span id="lastSyncTime" style="margin-left: 8px;">Never</span>
                </div>
                <button type="button" id="syncNowBtn" class="btn btn-primary" onclick="triggerSync()">
                    üîÑ Sync Now
                </button>
            </div>
            <div id="syncStats" style="margin-top: 10px; font-size: 14px; color: #666;">
                Loading sync status...
            </div>
        </div>

        <div id="syncResult" style="display: none; padding: 15px; border-radius: 4px; margin-top: 15px;">
        </div>
    </div>

    <div class="settings-card">
        <h3>üìÅ Watch Folder Import</h3>

        <p style="margin-bottom: 15px; color: #666;">
            Automatically import conversations from .zip and .json files dropped into a watched folder.
        </p>

        <form id="watchFolderForm">
            <div class="form-group">
                <label for="watch_folder_path">Watch Folder Path</label>
                <input
                    type="text"
                    id="watch_folder_path"
                    name="watch_folder_path"
                    placeholder="/path/to/watch/folder"
                    value="{{ settings.get('watch_folder_path', '') }}"
                >
                <div class="form-help">
                    Absolute path to the folder to monitor for import files. Subfolders <code>archive/</code> and <code>failed/</code> will be created automatically.
                </div>
            </div>

            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input
                        type="checkbox"
                        id="watch_folder_enabled"
                        name="watch_folder_enabled"
                        style="width: auto;"
                        {% if settings.get('watch_folder_enabled', 'false') == 'true' %}checked{% endif %}
                    >
                    <span>Enable Watch Folder</span>
                </label>
                <div class="form-help" style="margin-left: 28px;">
                    When enabled, the folder will be scanned periodically for new files.
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="btn btn-primary">Save Settings</button>
                <button type="button" class="btn btn-secondary" onclick="testWatchFolder()">Test Folder</button>
            </div>
        </form>

        <!-- Watch Folder Status Section -->
        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>Worker Status:</strong>
                    <span id="watchFolderWorkerStatus" style="margin-left: 8px;">
                        <span class="status-indicator">‚ö™</span> Checking...
                    </span>
                </div>
                <button type="button" class="btn btn-secondary" style="padding: 5px 10px;" onclick="refreshWatchFolderStatus()">
                    üîÑ Refresh
                </button>
            </div>
            <div id="watchFolderStats" style="margin-top: 10px; font-size: 14px; color: #666;">
                Loading status...
            </div>
        </div>
    </div>

    <div class="settings-card">
        <h3>üß† Embedding Configuration</h3>

        <!-- Worker Status Section -->
        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>Worker Status:</strong>
                    <span id="workerStatus" style="margin-left: 8px;">
                        <span class="status-indicator">‚ö™</span> Checking...
                    </span>
                </div>
                <button type="button" class="btn btn-secondary" style="padding: 5px 10px;" onclick="refreshEmbeddingStatus()">
                    üîÑ Refresh
                </button>
            </div>
            <div id="queueStats" style="margin-top: 10px; font-size: 14px; color: #666;">
                Loading queue statistics...
            </div>
        </div>

        <!-- Model Selection -->
        <form id="embeddingForm">
            <div class="form-group">
                <label for="embedding_model">Embedding Model</label>
                <select id="embedding_model" name="embedding_model" class="form-control">
                    <option value="sentence-transformers/all-MiniLM-L6-v2">all-MiniLM-L6-v2 (default - balanced, fast)</option>
                    <option value="sentence-transformers/paraphrase-MiniLM-L6-v2">paraphrase-MiniLM-L6-v2 (paraphrase detection)</option>
                    <option value="sentence-transformers/multi-qa-MiniLM-L6-v2">multi-qa-MiniLM-L6-v2 (question answering)</option>
                    <option value="sentence-transformers/all-MiniLM-L12-v2">all-MiniLM-L12-v2 (higher quality, slower)</option>
                </select>
                <div class="form-help">
                    Select the sentence transformer model for generating embeddings. Changing this will require regenerating all embeddings.
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="btn btn-primary">Save Model</button>
            </div>
        </form>
    </div>

    <div class="settings-card">
        <h3>‚ÑπÔ∏è Backend Information</h3>
        <p><strong>Version:</strong> <span id="versionInfo">Loading...</span></p>
        <p><strong>Database Backend:</strong> PostgreSQL with pgvector</p>
        <p><strong>Search Mode:</strong> Hybrid (Full-Text + Vector Search)</p>
        <p id="currentModelInfo"><strong>Embedding Model:</strong> Loading...</p>
    </div>
</div>

<!-- Confirmation Modal -->
<div id="confirmModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center;">
    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top: 0; color: #d9534f;">‚ö†Ô∏è Regenerate All Embeddings?</h3>
        <p id="confirmMessage" style="margin: 20px 0;">Loading...</p>
        <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin: 15px 0;">
            <p style="margin: 5px 0;"><strong>Current Model:</strong> <span id="confirmCurrentModel"></span></p>
            <p style="margin: 5px 0;"><strong>New Model:</strong> <span id="confirmNewModel"></span></p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button id="confirmCancelBtn" class="btn btn-secondary" style="flex: 1;" onclick="closeConfirmModal()">Cancel</button>
            <button id="confirmProceedBtn" class="btn btn-primary" style="flex: 1;" onclick="confirmRegeneration()">Confirm Regeneration</button>
        </div>
    </div>
</div>

<script>
    document.getElementById('settingsForm').addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const formData = new FormData(this);
        const settings = {
            openwebui_url: formData.get('openwebui_url'),
            openwebui_api_key: formData.get('openwebui_api_key')
        };
        
        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            });
            
            const data = await response.json();
            
            if (response.ok) {
                showMessage('Settings saved successfully!', 'success');
            } else {
                showMessage('Error: ' + (data.error || 'Failed to save settings'), 'error');
            }
        } catch (error) {
            showMessage('Error: ' + error.message, 'error');
        }
    });
    
    async function testConnection() {
        const url = document.getElementById('openwebui_url').value;
        const apiKey = document.getElementById('openwebui_api_key').value;

        if (!url || !apiKey) {
            showMessage('Please fill in both OpenWebUI URL and API Key', 'info');
            return;
        }

        showMessage('Testing connection...', 'testing'); // Use 'testing' type to prevent auto-hide

        try {
            // Create abort controller for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

            const response = await fetch(url + '/api/v1/health', {
                headers: {
                    'Authorization': 'Bearer ' + apiKey
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (response.ok) {
                showMessage('‚úÖ Connection successful!', 'success');
            } else {
                showMessage('‚ùå Connection failed: ' + response.status + ' ' + response.statusText, 'error');
            }
        } catch (error) {
            console.error('Test connection error:', error);
            if (error.name === 'AbortError') {
                showMessage('‚ùå Connection timeout: Server did not respond within 10 seconds', 'error');
            } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                showMessage('‚ùå Connection failed: Cannot reach server. Check the URL or try using the backend test.', 'error');
            } else {
                showMessage('‚ùå Connection failed: ' + error.message, 'error');
            }
        }
    }
    
    let messageTimeout = null;

    function showMessage(message, type) {
        const messageEl = document.getElementById('statusMessage');
        const messageTextEl = document.getElementById('statusMessageText');

        // Clear any existing timeout
        if (messageTimeout) {
            clearTimeout(messageTimeout);
            messageTimeout = null;
        }

        messageTextEl.textContent = message;
        messageEl.className = 'status-message status-' + type;
        messageEl.style.display = 'block'; // Explicitly show the message

        // Auto-hide info/success messages after 5 seconds (but not error or testing)
        if (type !== 'error' && type !== 'testing') {
            messageTimeout = setTimeout(() => {
                messageEl.style.display = 'none';
                messageTimeout = null;
            }, 5000);
        }
    }

    function dismissMessage() {
        const messageEl = document.getElementById('statusMessage');
        messageEl.style.display = 'none';

        // Clear any pending timeout
        if (messageTimeout) {
            clearTimeout(messageTimeout);
            messageTimeout = null;
        }
    }

    // ==== EMBEDDING CONFIGURATION FUNCTIONS ====

    let pendingEmbeddingChange = null;

    async function refreshEmbeddingStatus() {
        try {
            const response = await fetch('/api/embedding/status');
            const data = await response.json();

            // Update worker status
            const statusEl = document.getElementById('workerStatus');
            if (data.worker.status === 'running') {
                statusEl.innerHTML = '<span style="color: #28a745;">üü¢ Running</span>';
            } else {
                statusEl.innerHTML = '<span style="color: #dc3545;">üî¥ Stopped</span>';
            }

            // Update queue stats
            const queueEl = document.getElementById('queueStats');
            queueEl.innerHTML = `
                <strong>Queue:</strong>
                Pending: ${data.queue.pending} |
                Running: ${data.queue.running} |
                Completed: ${data.queue.completed} |
                Failed: ${data.queue.failed}
            `;

            // Update current model in backend info
            const modelInfo = document.getElementById('currentModelInfo');
            modelInfo.innerHTML = `<strong>Embedding Model:</strong> ${data.model.current}`;

            // Update version in backend info
            if (data.version) {
                const versionInfo = document.getElementById('versionInfo');
                versionInfo.textContent = data.version;
            }

            // Pre-select current model in dropdown
            const modelSelect = document.getElementById('embedding_model');
            if (modelSelect && data.model.current) {
                modelSelect.value = data.model.current;
            }

        } catch (error) {
            console.error('Failed to fetch embedding status:', error);
            document.getElementById('workerStatus').innerHTML = '<span style="color: #999;">‚ö™ Unknown</span>';
            document.getElementById('queueStats').textContent = 'Failed to load queue statistics';
        }
    }

    // Handle embedding form submission
    document.getElementById('embeddingForm').addEventListener('submit', async function(e) {
        e.preventDefault();

        const formData = new FormData(this);
        const newModel = formData.get('embedding_model');

        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    embedding_model: newModel
                })
            });

            const data = await response.json();

            if (data.requires_confirmation) {
                // Show confirmation modal
                pendingEmbeddingChange = {
                    new_model: data.new_model,
                    current_model: data.current_model
                };
                showConfirmModal(data);
            } else if (data.success) {
                showMessage(data.message || 'Model saved successfully', 'success');
                if (data.regeneration_started) {
                    showMessage(`Regeneration started: ${data.jobs_enqueued} jobs enqueued`, 'success');
                    // Refresh status to show updated queue
                    setTimeout(refreshEmbeddingStatus, 1000);
                }
            } else {
                showMessage('Error: ' + (data.error || 'Failed to save model'), 'error');
            }
        } catch (error) {
            showMessage('Error: ' + error.message, 'error');
        }
    });

    function showConfirmModal(data) {
        const modal = document.getElementById('confirmModal');
        document.getElementById('confirmMessage').textContent = data.message;
        document.getElementById('confirmCurrentModel').textContent = data.current_model;
        document.getElementById('confirmNewModel').textContent = data.new_model;

        modal.style.display = 'flex';

        // Focus cancel button (default action)
        setTimeout(() => {
            document.getElementById('confirmCancelBtn').focus();
        }, 100);
    }

    function closeConfirmModal() {
        document.getElementById('confirmModal').style.display = 'none';

        // Reset dropdown to current model when canceling
        if (pendingEmbeddingChange && pendingEmbeddingChange.current_model) {
            const modelSelect = document.getElementById('embedding_model');
            if (modelSelect) {
                modelSelect.value = pendingEmbeddingChange.current_model;
            }
        }

        pendingEmbeddingChange = null;
    }

    async function confirmRegeneration() {
        if (!pendingEmbeddingChange) {
            closeConfirmModal();
            return;
        }

        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    embedding_model: pendingEmbeddingChange.new_model,
                    confirm_regeneration: true
                })
            });

            const data = await response.json();

            closeConfirmModal();

            if (data.success && data.regeneration_started) {
                showMessage(`Regeneration started! ${data.jobs_enqueued} jobs enqueued.`, 'success');
                // Refresh status to show updated queue
                setTimeout(refreshEmbeddingStatus, 1000);
            } else {
                showMessage('Error: ' + (data.error || 'Failed to start regeneration'), 'error');
            }
        } catch (error) {
            closeConfirmModal();
            showMessage('Error: ' + error.message, 'error');
        }
    }

    // Load embedding status on page load
    document.addEventListener('DOMContentLoaded', function() {
        refreshEmbeddingStatus();
        refreshSyncStatus();
        refreshWatchFolderStatus();
    });

    // ==== WATCH FOLDER FUNCTIONS ====

    document.getElementById('watchFolderForm').addEventListener('submit', async function(e) {
        e.preventDefault();

        const formData = new FormData(this);
        const settings = {
            watch_folder_path: formData.get('watch_folder_path'),
            watch_folder_enabled: document.getElementById('watch_folder_enabled').checked ? 'true' : 'false'
        };

        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            });

            const data = await response.json();

            if (response.ok) {
                showMessage('Watch folder settings saved successfully!', 'success');
                // Refresh status after saving
                setTimeout(refreshWatchFolderStatus, 500);
            } else {
                showMessage('Error: ' + (data.error || 'Failed to save settings'), 'error');
            }
        } catch (error) {
            showMessage('Error: ' + error.message, 'error');
        }
    });

    async function testWatchFolder() {
        const folderPath = document.getElementById('watch_folder_path').value;

        if (!folderPath) {
            showMessage('Please enter a folder path to test', 'info');
            return;
        }

        showMessage('Testing folder access...', 'testing');

        try {
            const response = await fetch('/api/watch-folder/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ path: folderPath })
            });

            const data = await response.json();

            if (data.valid) {
                showMessage('Folder is valid and writable!', 'success');
            } else {
                showMessage('Folder test failed: ' + data.message, 'error');
            }
        } catch (error) {
            showMessage('Error testing folder: ' + error.message, 'error');
        }
    }

    async function refreshWatchFolderStatus() {
        try {
            const response = await fetch('/api/watch-folder/status');
            const data = await response.json();

            // Update worker status
            const statusEl = document.getElementById('watchFolderWorkerStatus');
            if (data.worker_status === 'running') {
                statusEl.innerHTML = '<span style="color: #28a745;">üü¢ Running</span>';
            } else {
                statusEl.innerHTML = '<span style="color: #dc3545;">üî¥ Stopped</span>';
            }

            // Update stats
            const statsEl = document.getElementById('watchFolderStats');
            let statsHtml = '';

            if (data.enabled) {
                statsHtml += `<strong>Status:</strong> Enabled`;
            } else {
                statsHtml += `<strong>Status:</strong> Disabled`;
            }

            if (data.folder_path) {
                statsHtml += ` | <strong>Path:</strong> ${data.folder_path}`;
            }

            if (data.last_check) {
                const lastCheck = new Date(data.last_check);
                statsHtml += `<br><strong>Last Check:</strong> ${lastCheck.toLocaleString()}`;
            }

            statsEl.innerHTML = statsHtml || 'No status available';

        } catch (error) {
            console.error('Failed to fetch watch folder status:', error);
            document.getElementById('watchFolderWorkerStatus').innerHTML = '<span style="color: #999;">‚ö™ Unknown</span>';
            document.getElementById('watchFolderStats').textContent = 'Failed to load status';
        }
    }

    // ==== SYNC FUNCTIONS ====

    async function refreshSyncStatus() {
        try {
            const response = await fetch('/api/sync/status');
            const data = await response.json();

            // Update last sync time
            const lastSyncEl = document.getElementById('lastSyncTime');
            if (data.last_openwebui_sync) {
                const syncDate = new Date(data.last_openwebui_sync);
                lastSyncEl.textContent = syncDate.toLocaleString();
            } else {
                lastSyncEl.textContent = 'Never';
            }

            // Update sync stats
            const statsEl = document.getElementById('syncStats');
            const sources = data.conversations_by_source || {};
            const openwebuiCount = sources.openwebui || 0;
            const syncBtn = document.getElementById('syncNowBtn');

            if (data.openwebui_configured) {
                let statsHtml = `
                    <strong>OpenWebUI Conversations:</strong> ${openwebuiCount} |
                    <strong>Total:</strong> ${data.total_conversations || 0}
                `;

                // Show sync progress or completion status
                if (data.sync_running) {
                    statsHtml += `<br><span style="color: #28a745;"><strong>Sync in progress:</strong> ${data.sync_progress || 'Starting...'}</span>`;
                    // Disable sync button while running
                    if (syncBtn) {
                        syncBtn.disabled = true;
                        syncBtn.textContent = '‚è≥ Syncing...';
                    }
                    // Auto-refresh while running
                    setTimeout(refreshSyncStatus, 3000);
                } else {
                    // Re-enable sync button
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.textContent = 'üîÑ Sync Now';
                    }
                    // Show last sync result if available
                    if (data.sync_progress && data.sync_progress !== 'Failed') {
                        statsHtml += `<br><span style="color: #666;"><strong>Last result:</strong> ${data.sync_progress}</span>`;
                    }
                }

                // Show last error if any
                if (data.sync_error) {
                    statsHtml += `<br><span style="color: #dc3545;"><strong>Last error:</strong> ${data.sync_error}</span>`;
                }

                statsEl.innerHTML = statsHtml;
            } else {
                statsEl.innerHTML = '<span style="color: #dc3545;">OpenWebUI not configured. Please save URL and API key above.</span>';
            }

        } catch (error) {
            console.error('Failed to fetch sync status:', error);
            document.getElementById('syncStats').textContent = 'Failed to load sync status';
        }
    }

    async function triggerSync() {
        const syncBtn = document.getElementById('syncNowBtn');
        const resultDiv = document.getElementById('syncResult');

        // Disable button and show loading state
        syncBtn.disabled = true;
        syncBtn.textContent = '‚è≥ Starting...';
        resultDiv.style.display = 'none';

        try {
            const response = await fetch('/api/sync/openwebui', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            const data = await response.json();

            // Show result
            resultDiv.style.display = 'block';

            if (data.success) {
                resultDiv.style.background = '#d4edda';
                resultDiv.style.border = '1px solid #c3e6cb';
                resultDiv.innerHTML = `
                    <strong style="color: #155724;">${data.message}</strong><br>
                    <span style="color: #155724;">
                        Progress will update automatically. You can close this page.
                    </span>
                `;

                // Start polling for status updates
                syncBtn.textContent = '‚è≥ Syncing...';
                setTimeout(refreshSyncStatus, 2000);
            } else {
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.border = '1px solid #f5c6cb';
                const errorMsg = data.errors && data.errors.length > 0 ? data.errors[0] : (data.error || 'Unknown error');
                resultDiv.innerHTML = `
                    <strong style="color: #721c24;">Sync Failed</strong><br>
                    <span style="color: #721c24;">${errorMsg}</span>
                `;
                // Re-enable button on error
                syncBtn.disabled = false;
                syncBtn.textContent = 'üîÑ Sync Now';
            }

        } catch (error) {
            resultDiv.style.display = 'block';
            resultDiv.style.background = '#f8d7da';
            resultDiv.style.border = '1px solid #f5c6cb';
            resultDiv.innerHTML = `
                <strong style="color: #721c24;">Sync Failed</strong><br>
                <span style="color: #721c24;">${error.message}</span>
            `;
            // Re-enable button on error
            syncBtn.disabled = false;
            syncBtn.textContent = 'üîÑ Sync Now';
        }
        // Note: button stays disabled until sync completes (handled by refreshSyncStatus)
    }
</script>
{% endblock %}
